# Necesitarás instalar graphviz y su binding para python antes de ejecutar este código:
# pip install graphviz

import graphviz

# Clase para representar un nodo del árbol binario
class Nodo:
    def __init__(self, clave):
        self.izquierdo = None
        self.derecho = None
        self.clave = clave

# Clase para el Árbol Binario
class ArbolBinario:
    def __init__(self):
        self.raiz = None

    # Método para insertar una nueva clave
    def insertar(self, clave):
        if self.raiz is None:
            self.raiz = Nodo(clave)
        else:
            self._insertar(self.raiz, clave)

    def _insertar(self, actual, clave):
        if clave < actual.clave:
            if actual.izquierdo is None:
                actual.izquierdo = Nodo(clave)
            else:
                self._insertar(actual.izquierdo, clave)
        else:
            if actual.derecho is None:
                actual.derecho = Nodo(clave)
            else:
                self._insertar(actual.derecho, clave)

    # Método para buscar una clave
    def buscar(self, clave):
        return self._buscar(self.raiz, clave)

    def _buscar(self, actual, clave):
        if actual is None or actual.clave == clave:
            return actual
        if clave < actual.clave:
            return self._buscar(actual.izquierdo, clave)
        return self._buscar(actual.derecho, clave)

    # Método para eliminar una clave
    def eliminar(self, clave):
        self.raiz = self._eliminar(self.raiz, clave)

    def _eliminar(self, actual, clave):
        if actual is None:
            return actual
        if clave < actual.clave:
            actual.izquierdo = self._eliminar(actual.izquierdo, clave)
        elif clave > actual.clave:
            actual.derecho = self._eliminar(actual.derecho, clave)
        else:
            # Caso 1: El nodo no tiene hijos o tiene un solo hijo
            if actual.izquierdo is None:
                return actual.derecho
            elif actual.derecho is None:
                return actual.izquierdo
            # Caso 2: El nodo tiene dos hijos, encontrar el sucesor en el subárbol derecho
            temp = self._minimo(actual.derecho)
            actual.clave = temp.clave
            actual.derecho = self._eliminar(actual.derecho, temp.clave)
        return actual

    def _minimo(self, nodo):
        actual = nodo
        while actual.izquierdo is not None:
            actual = actual.izquierdo
        return actual

    # Método para generar una representación gráfica del árbol
    def generar_grafico(self):
        dot = graphviz.Digraph()
        if self.raiz:
            self._agregar_nodo(dot, self.raiz)
        return dot

    def _agregar_nodo(self, dot, nodo):
        dot.node(str(nodo.clave), str(nodo.clave))
        if nodo.izquierdo:
            dot.edge(str(nodo.clave), str(nodo.izquierdo.clave))
            self._agregar_nodo(dot, nodo.izquierdo)
        if nodo.derecho:
            dot.edge(str(nodo.clave), str(nodo.derecho.clave))
            self._agregar_nodo(dot, nodo.derecho)

# Ejemplo de uso:
if __name__ == "__main__":
    arbol = ArbolBinario()
    arbol.insertar(50)
    arbol.insertar(30)
    arbol.insertar(70)
    arbol.insertar(20)
    arbol.insertar(40)
    arbol.insertar(60)
    arbol.insertar(80)

    print("Buscar 40:", arbol.buscar(40) is not None)  # True
    print("Eliminar 20")
    arbol.eliminar(20)
    print("Buscar 20:", arbol.buscar(20) is not None)  # False

    # Generar el gráfico y guardarlo en un archivo
    dot = arbol.generar_grafico()
    dot.render("arbol_binario", format="png", cleanup=False)

